---
title: "Untitled"
author: "Mike McPhee Anderson, FSA"
date: "2025-01-01"
output: html_document
---

```{r setup, include=FALSE}

library(glmnet)
library(xgboost)
library(recipes)
library(rpart)
library(rpart.plot)
library(splines)
library(tidyverse)
library(GA)
library(memoise)

knitr::opts_chunk$set(echo = TRUE)

```


## Mortality Improvement

### Background

This [SOA Paper](https://www.soa.org/globalassets/assets/files/resources/essays-monographs/2017-living-to-100/2017-living-100-monograph-hunt-villegas-paper.pdf) provides a comprehensive overview of Poisson mortality improvement models.

### Definitions

* The instantaneous *mortality rate*, also known as the *force of mortality*, for age $x$ at time $t$

$$ \mu_{x,t}$$

The *central rate of mortality* for age $x$ at time $t$, is defined as the number of deaths $d_x$ over the number of person-years $L_x$ (exposures), actuaries might incorrectly refer to this quantity as $q_{x,t}$, however there are subtle differences. 

$$ m_{x,t} = \frac{d_x}{L_x} = \exp(\pmb{X}\beta)$$

The **crude estimate of death** given the central exposure $e_x$ is given as 

$$ \hat{m_x} = \frac{d_x}{e_x}$$

The **probability of death over one year** is defined as $q_x$, which under the uniform distribution of deaths is defined as 

$$ q_x = \frac{m_x}{1 + 0.5 \times m_x}$$

The **Poisson log-bilinear model** is defined as below.  $\alpha_x$ is the age specific mortality rate, $\beta_t$ is the time / trend improvement, and $\gamma_x \times \kappa_t$ is the interaction between the two. 

$$ \ln(\mu_{x, t}) = \alpha_x + \beta_t + \gamma_x \times \kappa_t$$

## Load Data

```{r}

ilec_perm <- bind_rows(
  read_rds("ilec_perm_historical.rds"),
  read_rds("ilec_perm_recent.rds"),
  read_rds("ilec_simplified_issue.rds")) %>% 
  filter(
    attained_age <= 100
  )

head(ilec_perm)

```

```{r}

ilec_perm %>%
  select(attained_age, duration, observation_year) %>%
  summary()

```

```{r}
colnames(ilec_perm)
```


```{r}

model_data <- ilec_perm %>%
  group_by(attained_age, duration, observation_year) %>%
  summarise(
    number_of_deaths = sum(number_of_deaths),
    policies_exposed = sum(policies_exposed),
    expected_deaths_08_vbt_ult = sum(expected_deaths_08_vbt_ult),
    .groups="drop"
  ) %>%
  ungroup()

```


```{r}

approx_ecdf <- function(df, grp_col) {
  
  ptile_tbl <- ilec_perm %>%
    group_by({{grp_col}}) %>%
    summarise(
      tot_exposures = sum(number_of_deaths),
      .groups = "drop"
    ) %>%
    arrange({{grp_col}}) %>%
    mutate(
      cumu_tot_expos = cumsum(tot_exposures)
    ) %>%
    ungroup() %>%
    mutate(
      pct_tot_expos = cumu_tot_expos / sum(tot_exposures)
    )
  
  ptile_x_vals <- ptile_tbl %>% pull({{grp_col}})
  
  find_p_val_argmin <- function(p_val) {
    p_val_diff <- abs((p_val - ptile_tbl$pct_tot_expos))
    ptile_x_vals[which((p_val_diff == min(p_val_diff)))]
  }
  
  function(ptile_cuts) {
    vec_vals <- vapply(ptile_cuts, find_p_val_argmin, c(ptile_x_vals[1]))
    names(vec_vals) <- ptile_cuts
    vec_vals
  }
}

duration_ptiles <- unique(approx_ecdf(ilec_perm, duration)(seq(0.05, 0.95, 0.1)))
attage_ptiles <- unique(approx_ecdf(ilec_perm, attained_age)(c(0.025, seq(0.1, 0.9, 0.1), 0.975)))
observation_year_ptiles <- unique(approx_ecdf(ilec_perm, observation_year)(seq(0.25, 0.75, by=0.25)))

ATTAGE_PART = "splines::ns(attained_age, Boundary.knots = c(25, 100), knots=c(%KNOTS%))"
OBS_YR_PART = "splines::ns(observation_year, Boundary.knots = c(2009, 2018), knots=c(%KNOTS%))"
DUR_PART = "splines::ns(duration, Boundary.knots = c(1, 38), knots=c(%KNOTS%))"

formula_template <- stringr::str_glue("number_of_deaths ~ offset(log(expected_deaths_08_vbt_ult)) + {ATTAGE_PART}*{DUR_PART} + {ATTAGE_PART}*{OBS_YR_PART}")

spline_locations <- list()

spline_locations[[DUR_PART]] <- duration_ptiles
spline_locations[[ATTAGE_PART]] <- attage_ptiles
spline_locations[[OBS_YR_PART]] <- observation_year_ptiles 

```


```{r}

N_BITS <- length(duration_ptiles) + length(attage_ptiles) + length(observation_year_ptiles)

bit_str_to_formula <- function(bit_string) {
  
  bit_str_iter <- bit_string
  full_formula <- formula_template
  
  for (formula_i in 1:length(spline_locations)) {
    
    curr_part <- names(spline_locations)[formula_i]
    all_knots <- spline_locations[[curr_part]]
    curr_knot_locs <- which(bit_str_iter[1:length(all_knots)] == 1)
    curr_knots <- all_knots[curr_knot_locs]
    
    curr_knot_str <- paste0(curr_knots, collapse=",")
    curr_formula <- stringr::str_replace(curr_part, "%KNOTS%", curr_knot_str)
    full_formula <- stringr::str_replace_all(full_formula, fixed(curr_part), curr_formula)
    
    # shift bit string
    bit_str_iter <- bit_str_iter[-(1:length(all_knots))]
  }
  
  as.formula(full_formula)
}

glm_fitness <- function(bit_string) {
  -1 * AIC(
    glm(bit_str_to_formula(bit_string), family = poisson(), data = model_data)
  )
}


# https://cran.r-project.org/web/packages/GA/vignettes/GA.html#memoization
best_model <- GA::ga(type="binary", 
       memoise::memoise(glm_fitness), 
       popSize=40, 
       nBits = N_BITS, 
       maxiter = 50, 
       parallel = F,
       pmutation = 0.7,
       suggestions = rbind(
         rep(0, N_BITS),
         rep(1, N_BITS)
       ),
       pcrossover=0.2)

bit_str_to_formula(best_model@solution)

```

```{r}

# 128,345.0

final_formula <- number_of_deaths ~ offset(log(expected_deaths_08_vbt_ult)) + 
    splines::ns(attained_age, Boundary.knots = c(25, 100), knots = c(45, 
        58, 66, 71, 90, 94)) * splines::ns(duration, Boundary.knots = c(1, 
        38), knots = c(10, 17, 20, 27, 33)) + splines::ns(attained_age, 
    Boundary.knots = c(25, 100), knots = c(45, 58, 66, 71, 90, 
        94)) * splines::ns(observation_year, Boundary.knots = c(2009, 
    2018), knots = c(2014))

final_fit <- glm(final_formula, family = poisson(), data = model_data)

AIC(final_fit)

final_fit.summary <- summary(final_fit)

(final_fit.summary$null.deviance - final_fit.summary$deviance) / final_fit.summary$null.deviance

```

```{r}

coef_groups <- tibble(
  coef_name = names(coef(final_fit))
)



```


### Non-smokers

#### Evaluate knot locations

Very heavily skewed towards old age deaths, looks like first knot should be
places around 50 (5% of the deaths), second around 65.

```{r}

plot_data <- df_study_data %>%
  filter(
    smoker_status == "NONSMOKER",
    attained_age >= 25,
    attained_age <= 90) %>%
  group_by(attained_age, gender) %>%
  summarise(
    n_deaths = sum(number_of_deaths)
  ) %>%
  ungroup() %>%
  group_by(gender) %>%
  arrange(attained_age) %>%
  mutate(
    cumulative_pct_of_deaths = cumsum(n_deaths) / sum(n_deaths)
  ) 

ggplot(plot_data, aes(x=attained_age, y=cumulative_pct_of_deaths, group=gender, color=gender)) +
  geom_line() +
  scale_y_continuous(
    labels = scales::percent_format(), 
    transform = scales::pseudo_log_trans(sigma = 0.01),
    breaks=seq(0,1,by=0.1)) +
  scale_x_continuous(breaks=seq(0, 120, by=10)) +
  # eye-ball first knot location
  geom_hline(yintercept = 0.05) +
  geom_vline(xintercept = 50) +
  # eye-ball second knot location
  geom_hline(yintercept = 0.15) +
  geom_vline(xintercept = 65) +
  xlab("Attained Age") +
  ylab("Cumulative % of Deaths") +
  theme_bw()

```

### Build inferential model

By accounting for the other time variables (attained age + duration), we can see
what is left over by observation (calendar) year.  This will give us a starting 
point for a mortality improvement assumption.  Cap the duration at 20, since 
underwriting should largely be worn-off by that time.

```{r}

df_model_data <- df_study_data %>%
  filter(smoker_status == "NONSMOKER",
         number_of_preferred_classes != "NA",
         attained_age >= 25,
         attained_age <= 90) %>%
  mutate(
    gender = factor(gender, levels=c("MALE", "FEMALE")),
    capped_duration = pmin(20, duration),
    expected_claims = qx * policies_exposed,
    face_amount_band = ordered(face_amount_band, levels=!!face_amount_order),
    face_amount_band_int = as.integer(face_amount_band)
  ) %>%
  filter(face_amount_band_int > 2) %>%
  group_by(observation_year, gender, attained_age, capped_duration, face_amount_band, face_amount_band_int) %>%
  summarise(
    number_of_deaths = sum(number_of_deaths),
    expected_claims = sum(expected_claims),
    .groups="drop") %>%
  ungroup() %>%
  filter(expected_claims > 0)

X_mat <- model.matrix(
  number_of_deaths ~ gender * 
    splines::ns(attained_age, Boundary.knots = c(25, 90), knots = c(35, 45, 55, 65, 75, 85)) *
    splines::ns(capped_duration, Boundary.knots=c(1, 20), knots = c(5, 10, 15)) - 1,
  data=df_model_data
)

X_offset <- log(df_model_data$expected_claims)

y_mat <- df_model_data$number_of_deaths

```

#### Run CV

Select the lambda for the lasso based on a rudimentary CV.

```{r}

cv_model <- cv.glmnet(
  X_mat,
  y_mat,
  family="poisson",
  offset=X_offset,
  fit_intercept=T
)

cv_model

```

#### Build Model

Fit the model and plot the lambda selected via CV

```{r}

glmnet_model <- glmnet::glmnet(
  X_mat,
  y_mat,
  family="poisson",
  offset=X_offset,
  fit_intercept=T
)

lambda_diff <- abs(glmnet_model$lambda - cv_model$lambda.1se)

LAMBDA_INDEX <- which(lambda_diff == min(lambda_diff))

best_lambda_value <- glmnet_model$lambda[LAMBDA_INDEX]

plot(glmnet_model$dev.ratio, type="l")
points(LAMBDA_INDEX, glmnet_model$dev.ratio[LAMBDA_INDEX])

```


#### Check Model

```{r}

model_pred <- predict(
  glmnet_model,
  newx=X_mat,
  newoffset = X_offset,
  s=best_lambda_value,
  type = "response")

df_model_data$model_pred <- model_pred

# sanity check
sum(df_model_data$number_of_deaths) / sum(model_pred)

```

#### Look for any major areas of poor fit

Use a decision tree to evaluate the model fit / residuals on the training set.

* Early durations don't look great, but there aren't a lot of deaths

```{r}

model_errors <- as.matrix(df_model_data[,c("model_pred","number_of_deaths")])

rpart_model <- rpart(
  model_errors ~ capped_duration + attained_age + gender,
  data=df_model_data,
  method="poisson",
  control = rpart.control(cp=0.001, maxdepth = 3))

rpart.plot(rpart_model, digits=3)

```

#### Check Mortality Improvement

Downward sloping lines mean that mortality is getting better over time, this
is called *mortality improvement*.  It's generally attributed to changes in lifestyle (fewer smokers),
and medical advances (statins, better cancer treatment, etc.).

* Evidence of improvement between 55 and 75

* The upward sloping lines at earlier ages is consistent with *deaths of despair* that occured following the 2008 recession, where mortality worsened for younger ages.


```{r}

age_cuts <- c(-Inf, seq(35, 85, by=10), Inf)

plot_data <- df_model_data %>%
  filter(observation_year < 2018) %>%
  mutate(
    age_group = cut(attained_age, breaks=!!age_cuts)
  ) %>%
  group_by(age_group, gender, observation_year) %>%
  summarise(
    number_of_deaths = sum(number_of_deaths),
    model_pred = sum(model_pred),
    .groups="drop"
  ) %>%
  ungroup()

ggplot(plot_data, aes(x=observation_year, y=log(number_of_deaths/model_pred), color=gender, group=gender)) +
  facet_wrap(~ age_group, scales="free_y") +
  geom_line() +
  geom_smooth(method="lm", se=F) +
  ggtitle("Mortality Improvement Check") +
  theme_bw() +
  xlab("Observation Year") +
  ylab("Log A/E")

```

No improvement in 75-85, regardless of the face amounts

```{r}

plot_data <- df_model_data %>%
  filter(observation_year < 2018) %>%
  mutate(
    age_group = cut(attained_age, breaks=!!age_cuts)
  ) %>%
  filter(age_group == "(75,85]") %>%
  group_by(face_amount_band, gender, observation_year) %>%
  summarise(
    number_of_deaths = sum(number_of_deaths),
    model_pred = sum(model_pred),
    .groups="drop"
  ) %>%
  ungroup()

ggplot(plot_data, aes(x=observation_year, y=log(number_of_deaths/model_pred), color=gender, group=gender)) +
  facet_wrap(~ face_amount_band, scales="free_y") +
  geom_line() +
  geom_smooth(method="lm", se=F) +
  ggtitle("Mortality Improvement Check - 75 to 84") +
  theme_bw() +
  xlab("Observation Year") +
  ylab("Log A/E")

```

No strong evidence of improvement at 85+

```{r}

plot_data <- df_model_data %>%
  filter(observation_year < 2018) %>%
  mutate(
    age_group = cut(attained_age, breaks=!!age_cuts)
  ) %>%
  filter(age_group == "(85, Inf]") %>%
  group_by(face_amount_band, gender, observation_year) %>%
  summarise(
    number_of_deaths = sum(number_of_deaths),
    model_pred = sum(model_pred),
    .groups="drop"
  ) %>%
  ungroup()

ggplot(plot_data, aes(x=observation_year, y=log(number_of_deaths/model_pred), color=gender, group=gender)) +
  facet_wrap(~ face_amount_band, scales="free_y") +
  geom_line() +
  geom_smooth(method="lm", se=F) +
  ggtitle("Mortality Improvement Check - 85+") +
  theme_bw() +
  xlab("Observation Year") +
  ylab("Log A/E")

```



